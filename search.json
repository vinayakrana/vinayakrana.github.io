[
  {
    "objectID": "tech_nuggets/index.html",
    "href": "tech_nuggets/index.html",
    "title": "Tech Nuggets",
    "section": "",
    "text": "Understanding the “why” behind system behavior is a core skill in software and ML engineering. These posts demonstrate a habit of going deep into how things work, whether that’s a faster dictionary lookup, how PyTorch builds a dynamic computation graph, or what causes a memory spike in Docker containers."
  },
  {
    "objectID": "tech_nuggets/index.html#latest-posts",
    "href": "tech_nuggets/index.html#latest-posts",
    "title": "Tech Nuggets",
    "section": "Latest Posts",
    "text": "Latest Posts"
  },
  {
    "objectID": "apps.html",
    "href": "apps.html",
    "title": "ScholarBot: AI-powered chatbot designed to assist with academic queries",
    "section": "",
    "text": "ScholarBot: AI-powered chatbot designed to assist with academic queries"
  },
  {
    "objectID": "timeline.html",
    "href": "timeline.html",
    "title": "Timeline",
    "section": "",
    "text": "Will be updated soon…."
  },
  {
    "objectID": "timeline.html#section",
    "href": "timeline.html#section",
    "title": "Timeline",
    "section": "",
    "text": "Will be updated soon…."
  },
  {
    "objectID": "papers/index.html",
    "href": "papers/index.html",
    "title": "Publications",
    "section": "",
    "text": "Coming soon….."
  },
  {
    "objectID": "papers/index.html#section",
    "href": "papers/index.html#section",
    "title": "Publications",
    "section": "",
    "text": "Coming soon….."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Vinayak Rana",
    "section": "",
    "text": "Vinayak Rana is a Master’s student in Artificial Intelligence at IIT Gandhinagar. He is an active member of the Sustainability Lab, advised by Prof. Nipun Batra. His interests lie in building practical and reliable AI systems, with a focus on spatiotemporal modeling, active learning and natural language processing. Vinayak is passionate about applying machine learning techniques to solve real-world problems and is actively exploring opportunities to contribute to impactful AI research and development. He secured an All India Rank (AIR) of 733 in GATE CS 2024."
  },
  {
    "objectID": "tech_nuggets/posts/dict_key_lookup.html",
    "href": "tech_nuggets/posts/dict_key_lookup.html",
    "title": "Dict Lookup",
    "section": "",
    "text": "In Python, checking whether a key exists in a dictionary is a common operation. But there’s more than one way to write it:\nif key in my_dict: ...\nif key in my_dict.keys(): ...\nAt first glance, both seem correct and equivalent. But they are not equal in performance or clarity.\nIn this post, we’ll dive into:\n\nThe internal differences between the two\nThe disassembled bytecode\nReal-world benchmarks using timeit\nBest practices and when it actually matters\n\nLet’s compare the bytecode of two functions, one using in dict and the other using in dict.keys() to see what Python does under the hood.\n\nimport dis\n\ndef direct_lookup(hmap, x):\n    return x in hmap\n\ndef keys_lookup(hmap, x):\n    return x in hmap.keys()\n\ndis.dis(direct_lookup)\nprint(\"-\" * 40)\ndis.dis(keys_lookup)\n\n  4           0 LOAD_FAST                1 (x)\n              2 LOAD_FAST                0 (hmap)\n              4 CONTAINS_OP              0\n              6 RETURN_VALUE\n----------------------------------------\n  7           0 LOAD_FAST                1 (x)\n              2 LOAD_FAST                0 (hmap)\n              4 LOAD_METHOD              0 (keys)\n              6 CALL_METHOD              0\n              8 CONTAINS_OP              0\n             10 RETURN_VALUE\n\n\n\nx in hmap\n\nDirectly uses COMPARE_OP with in on the dictionary\nCalls dict.__contains__, which is optimized and fast\n\n\n\nx in hmap.keys()\n\nCalls .keys() → creates a dict_keys view object\nPerforms a membership test on the view\n\nThis adds extra function calls and memory allocation, even though the lookup is still O(1).\nLet’s use timeit to compare the performance of both lookup styles over 100,000 iterations.\n\nimport timeit\n\nsetup = \"hmap = dict(zip(range(10000), range(10000))); x = 9999\"\nstmt1 = \"x in hmap\"\nstmt2 = \"x in hmap.keys()\"\n\ntime_direct = timeit.timeit(stmt1, setup=setup, number=100_000)\ntime_keys = timeit.timeit(stmt2, setup=setup, number=100_000)\n\nprint(f\"'x in hmap'       : {time_direct:.5f} sec\")\nprint(f\"'x in hmap.keys()': {time_keys:.5f} sec\")\n\n'x in hmap'       : 0.00363 sec\n'x in hmap.keys()': 0.00700 sec\n\n\n\n\nSummary\n\n\n\nStyle\nPerformance\nMemory\n\n\n\n\nx in dict\nFast\nLow\n\n\nx in dict.keys()\nSlower\nHigher\n\n\n\n\n\nWhen to Use .keys()\nUse .keys() only when you need to iterate over or manipulate the entire view object — not for simple membership tests.\n\n\n\nWhy It Matters\nWhile the difference is small in absolute terms, understanding Python internals helps write clearer and more efficient code. It also prepares you to debug or optimize larger systems more confidently."
  }
]