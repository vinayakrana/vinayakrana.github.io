{
  "hash": "5544ce300c0ec0a0bb09be0ccaecb958",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Dict Lookup\"\ndescription: \"`in dict` vs `in dict.keys()`\"\ndate: 2025-06-27\ncategories: [python, performance, internals]\nformat: html\nexecute: \n  enabled: True\n---\n\nIn Python, checking whether a key exists in a dictionary is a common operation. But there's more than one way to write it:\n\n```python\nif key in my_dict: ...\nif key in my_dict.keys(): ...\n```\n\nAt first glance, both seem correct and equivalent. But they are not equal in performance or clarity.\n\nIn this post, we'll dive into:\n\n* The internal differences between the two\n* The disassembled bytecode\n* Real-world benchmarks using timeit\n* Best practices and when it actually matters\n\nLet's compare the bytecode of two functions, one using `in dict` and the other using `in dict.keys()` to see what Python does under the hood.\n\n::: {#2938e382 .cell execution_count=1}\n``` {.python .cell-code}\nimport dis\n\ndef direct_lookup(hmap, x):\n    return x in hmap\n\ndef keys_lookup(hmap, x):\n    return x in hmap.keys()\n\ndis.dis(direct_lookup)\nprint(\"-\" * 40)\ndis.dis(keys_lookup)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  4           0 LOAD_FAST                1 (x)\n              2 LOAD_FAST                0 (hmap)\n              4 CONTAINS_OP              0\n              6 RETURN_VALUE\n----------------------------------------\n  7           0 LOAD_FAST                1 (x)\n              2 LOAD_FAST                0 (hmap)\n              4 LOAD_METHOD              0 (keys)\n              6 CALL_METHOD              0\n              8 CONTAINS_OP              0\n             10 RETURN_VALUE\n```\n:::\n:::\n\n\n### `x in hmap`\n- Directly uses `COMPARE_OP` with `in` on the dictionary\n- Calls `dict.__contains__`, which is optimized and fast\n\n### `x in hmap.keys()`\n- Calls `.keys()` → creates a `dict_keys` view object\n- Performs a membership test on the view\n\nThis adds extra function calls and memory allocation, even though the lookup is still O(1).\n\nLet’s use `timeit` to compare the performance of both lookup styles over 100,000 iterations.\n\n::: {#38506820 .cell execution_count=2}\n``` {.python .cell-code}\nimport timeit\n\nsetup = \"hmap = dict(zip(range(10000), range(10000))); x = 9999\"\nstmt1 = \"x in hmap\"\nstmt2 = \"x in hmap.keys()\"\n\ntime_direct = timeit.timeit(stmt1, setup=setup, number=100_000)\ntime_keys = timeit.timeit(stmt2, setup=setup, number=100_000)\n\nprint(f\"'x in hmap'       : {time_direct:.5f} sec\")\nprint(f\"'x in hmap.keys()': {time_keys:.5f} sec\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'x in hmap'       : 0.00363 sec\n'x in hmap.keys()': 0.00700 sec\n```\n:::\n:::\n\n\n### Summary\n\n| Style               | Performance | Memory | \n|--------------------|-------------|--------|\n| `x in dict`         | Fast        | Low    | \n| `x in dict.keys()`  | Slower      | Higher |\n\n### When to Use `.keys()`\nUse `.keys()` only when you need to iterate over or manipulate the entire view object — not for simple membership tests.\n\n---\n\n### Why It Matters\n\nWhile the difference is small in absolute terms, understanding Python internals helps write clearer and more efficient code. It also prepares you to debug or optimize larger systems more confidently.\n\n",
    "supporting": [
      "dict_key_lookup_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}